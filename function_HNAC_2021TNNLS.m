function [ ymax, C_NAC_update, quantzError_NAC_update_2 ] = function_HNAC_2021TNNLS( X_tr, ...    C_init, maxStepNumber, init_y_cls_VQ, isplot_simuCampaign, figNr, alpha, isInstant_Ck_update, strTitle, W_ori )N = size(X_tr, 2);ymax = init_y_cls_VQ;nrClus = size(C_init,2);label_vec = [1:nrClus];C_NAC_update = C_init;label = [1:nrClus];[ quantznError_2_NAC_vec, Nk_vec ] = function_HNACquantzError_vec( X_tr, ymax, label, alpha );quantzError_NAC_update_2 = [];quantzError_NAC_update_2(1) = sum(quantznError_2_NAC_vec);quanErr_NAC_step = [];quanErr_NAC_step(1) = quantzError_NAC_update_2(1);n_epoch = 1;continueIter = true;while (n_epoch < maxStepNumber) && (continueIter)    ymax_prev = ymax;    C_NAC_update_prev = C_NAC_update;    for i_MB = 1:N        %%%%%%%%% Step 1: Expectation step        %%% Determining the winner clusters for kmeans        DELTA_kmeans_vec = [];        DELTA_kLn_vec = [];        uz_vq_vec = [];        dlt_kLn_vec = [];        i_MB_clstrIndx = ymax(i_MB);        for kk = 1:nrClus            %k-means            uz_vq_vec(kk) = norm( X_tr(:,i_MB) - C_NAC_update(:,kk) )^2 ;                        %k-Ln            tmp_inds_j = [];            tmp_inds_j = find( ymax == label_vec(kk) );                        if (length(tmp_inds_j) > 0)                dlt_kLn_vec(kk) = 2*sum( W_ori(i_MB, tmp_inds_j) ); %sum( W_ori(i_MB, tmp_inds_j) );  %standard GADIA            else                dlt_kLn_vec(kk) = 0;            end            %        end        DELTA_kmeans_vec = (1-alpha)*( uz_vq_vec - uz_vq_vec(i_MB_clstrIndx) );        DELTA_kLn_vec = alpha * ( dlt_kLn_vec - dlt_kLn_vec(i_MB_clstrIndx) );        %%%                tmpsumdelta = DELTA_kmeans_vec + DELTA_kLn_vec;        ind_winnerClsSet = find(tmpsumdelta < 0);                [tmpmin tmpindx] = min(tmpsumdelta);        if (tmpmin<0)            Nk_prev = Nk_vec;            tmpTrueClsIndex = tmpindx;            if ( i_MB_clstrIndx ~=  tmpTrueClsIndex )                ymax(i_MB) = tmpTrueClsIndex;  %Assignment of data s to cluster z_vq                Nk_vec(i_MB_clstrIndx) = Nk_vec(i_MB_clstrIndx) - 1; %Nk of previous cluster is decreased by 1 because it may go to another cls                Nk_vec(tmpTrueClsIndex) = Nk_vec(tmpTrueClsIndex) + 1; %Nk of cls z_vq is increased by 1 bcs data s is assigned to cls z_vq.                %If z_vq = ymax(i_MB), then it means data si_MB remains in its current cls bcs it is already the best cls.                                if (isInstant_Ck_update)                    %Updating ALL the cluster centroids although only two of them changed!                    for jkl = 1:nrClus                        tmpinxvctr = [];                        tmpinxvctr = find(ymax == jkl);                        if isempty(tmpinxvctr) %if any cluster is EMPTY, then we give a sample to this cluster so that it is not empty.                            tmpindx = jkl*N/nrClus;                            ymax(tmpindx) = jkl;                            C_NAC_update(:, jkl) = X_tr(:, tmpindx);                        else                            C_NAC_update(:, jkl) = mean( X_tr(:, tmpinxvctr), 2 );                        end                        %C_NAC_update(:, jkl) = mean( X_tr(:, tmpinxvctr), 2 );                                            end                                    end                                [ tmpQuanErr_NAC_step_vec, tmp_counter_step_vec ] = function_HNACquantzError_vec( X_tr, ymax, label, alpha );                quanErr_NAC_step = [ quanErr_NAC_step  sum(tmpQuanErr_NAC_step_vec) ];            end %if ( i_MB_clstrIndx ~=  tmpTrueClsIndex )        end  %if ~isempty(ind_win...                            end %i_MB=1:N        %%%%%%%%% enf of step 1    %After ALL data points cluster indices have been updated in step 1, we update the centroids in step 2.    %Step 2: Maximization step    if (~isInstant_Ck_update)        for jkl = 1:nrClus            tmpinxvctr = [];            tmpinxvctr = find(ymax == jkl);            if isempty(tmpinxvctr) %if any cluster is EMPTY, then we give a sample to this cluster so that it is not empty.                tmpindx = jkl*N/nrClus;                ymax(tmpindx) = jkl;                C_NAC_update(:, jkl) = X_tr(:, tmpindx);            else                C_NAC_update(:, jkl) = mean( X_tr(:, tmpinxvctr), 2 );            end        end        %epoch        [ quantznError_2_NAC_vec, tmp_counter_2_vec ] = function_HNACquantzError_vec( X_tr, ymax, label, alpha );        quantzError_NAC_update_2 = [ quantzError_NAC_update_2  sum(quantznError_2_NAC_vec) ];    end        %%%%%%%%% enf of step 2        %isplotCenterEvolution = 1;    isplotCenterEvolution = isplot_simuCampaign;        %epoch ended!    n_epoch = n_epoch +1;    %if ( norm(ymax_prev - ymax) == 0 )    %if ( norm(C_NAC_update_prev - C_NAC_update) == 0 )    if ( norm( max(C_NAC_update_prev - C_NAC_update) ) == 0 )        continueIter = ~true;    end    end  %whilemrkrSz = 5;lWdth = 3;fntSzL = 14;figure; plot( quantzError_NAC_update_2, 'ko-', 'MarkerSize', mrkrSz, 'LineWidth', lWdth  ), grid,set(gca, 'FontName', 'Arial', 'FontWeight', 'bold', 'FontAngle', 'normal', 'FontSize', fntSzL);stringTitle = strcat('H-NAC cost function - epoch, ', strTitle);title(stringTitle)%title('H-NAC cost function')xlabel( 'epoch number ', 'FontName', 'Helvetica', 'FontSize', fntSzL, 'FontWeight', 'bold' )ylabel( 'Q_{HN}(t)', 'FontName', 'Helvetica', 'FontSize', fntSzL, 'FontWeight', 'bold' )figure; plot( quanErr_NAC_step, 'ko-', 'MarkerSize', mrkrSz, 'LineWidth', lWdth  ), grid,set(gca, 'FontName', 'Arial', 'FontWeight', 'bold', 'FontAngle', 'normal', 'FontSize', fntSzL);stringTitle = strcat('H-NAC cost function - step, ', strTitle);title(stringTitle)xlabel( 'step number [t]', 'FontName', 'Helvetica', 'FontSize', fntSzL, 'FontWeight', 'bold' )ylabel( 'Q_{HN}(t)', 'FontName', 'Helvetica', 'FontSize', fntSzL, 'FontWeight', 'bold' )%+++++++++++++++++++